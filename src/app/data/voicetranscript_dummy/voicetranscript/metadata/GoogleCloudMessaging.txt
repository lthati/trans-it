SPEAKER: M1
Hello there my name is to be beer and I leave the cloud messaging team at Google. I'm going to talk about some of the awesome API that Google Cloud messaging or GCM provides the same provides that itself API to send messages from a server to an application efficiently and reliably. I want to thank all the developers using Google Cloud messaging because it really helps the ecosystem by minimizing the impact your application has on battery life Radio Shake ups and network signaling. Let's quickly look at some of the API is required to use GCM to use UCM an application needs a registration ID use this registration I need to send messages to a particular device. Multicast lets you send messages to up to a thousand recipients with a single request. And you can't set time to live on each request to tell GCM when to expire the message. So what's new in 2014. Today I've covered three key features that GCM provides. Simply base cloud connection server upstream messaging and use in order of occasions. In 2013 we opened the API to a limited set of developers. Since then we've added a bunch of new features with these API and made them faster and more robust. We saw tremendous response and interest from developers around the API. And I'm really excited to announce that these services are now open for all developers. Let's talk about GCM X and P-P and point also known as the cloud connection server. Cloud connection server or s.c.s provides a persistent asynchronous bidirectional connection. Do you always do as you see in servers. This is a very powerful service as it provides a virtual connection between your server and your users. You seem connected devices. This connection can be used to reliably send and receive messages. Here's how you can connect to s.c.s. I'm using a simple X and B B library in bytes and to connect to s.c.s. As you can see GCM Dargaville API is a com is the euro and 5 2 3 5 is the part you simply need to connect the dots and point and authenticate using your project's API key. Next step is to start sending messages. These messages include a payload that contains a target application data and a message ID since sending why it's an asynchronous this ID uniquely identifies the next NPB connection. So when you see a sense and act back to your server it will use this message id to identify the message. Therefore it is important that this message ID is not only unique but also present in the request. Let's take a look at what an act or not meant for this message looks like message type would indicate an act or an act and give something back. There isn't any record to describe what went wrong. So when you implementing a s.c.s connection Here's what you need to know. We allow a maximum of 100 connections per sender and the maximum outstanding messages per connection is also hundred. Are improved for handling lets you know more precisely what went wrong. Here's an example of a control message describing that a connection is draining. What this message means is that the sender should not send any more messages on this connection. Any new messages on this connection. We'll get back and back within the record indicating that the connection is draining. We have also added new codes for other types of errors like taste and parsing etc.. So what we learn so far is that with X and B B and point GCM provides the ability to have a persistent bidirectional connection to your servers. We also saw how to send messages down to a device using this connection. Next we will take a look at our awesome upstream messaging API that lets you send messages from the application on a device to your server. We have made a lot of changes to make upstream testing fast and reliable and I'm happy to say that it's now open to all developers. So let's take a look. Since the connection between the device and GCM already exists it's a low latency and no handshake is needed. These messages are saved locally. If the device is off line and are sent when you have a connection. We use the same reliable message queue technology that we use for downstream messages. So if we lose a connection to your server we will deliver the messages once the connection is reestablished. We will delete your messages once we get an arc from your server. In order to receive an upstream message your server should be connected to s.c.s. Here's an example of how to send an upstream message using Google Cloud messaging API. Just set the project id as a destination and we will deliver the message to your server. You can set up a set time to live in the API call. This is what actually looks like once again since the response is asynchronous message ID is used to identify the message. Have something to keep in mind when using of free messaging. No pending messages on a connection more than 100 we either free messages if your server fails to connect for more than 24 hours. We will also allow a maximum of Quinby and three messages from a single device. So acking is required. And similar to downstream messages the maximum payload size allowed for upstream is for Kate OK. Here's one of my favorite media if he hasn't GCM delivery receipts when sending messages to a device a common request from developers is to get more insight into the state of the message and to know if the message was delivered. For example you're writing a messaging app and would like to show your sender if the message was delivered with CCS. You can do that now. We're adding this new feature called delivery receipts. Here's an example on how you can request a receipt for a message in the Jason pillar of the message you just said the feel delivery receipt requested to true by default. The value was fots. Here's a receipt message. This message will have a new message ID from will be set to GCM. Google AP as dot com. And type as receipt. There are four fields I'd be out in the response to error message status original message ID title send and the registration ID of the original message. Now these users have multiple devices and hence receive notifications multiple times. This can be used notifications from a useful feature to an annoyance. Thankfully TCM provides a convenient way to call user notifications to reach all devices for user and help you synchronize notifications including dismissal. I'll talk more about businesses that have it. With user notifications. You can target all devices belonging to a user with a single request. This is a very powerful API and allows you to be smarter about the notifications. I'll give you a couple of examples. You can set a short TTL so the notification will only be sent to a device that is currently connected. Another example is to use option of delay of at idle. Imagine your user has a phone that they use all day and a tablet that sits I let on by setting the delay while I look at a TTL. You can send the notification only to the phone that is actively used. Pretty useful right. To send messages to all devices for user. You need a notification key. The application server can get a key by adding or removing registration to the notification name. Let's see how you can get a notification key. As the end point to get a key and the to be beheader. The request is authenticated using your project's API key so forcing me out of iteration to a notification key you can do a period and then if a user installs the app on another device you can use and add an important field as the notification key name for us it's just a unique identifier that you use to identify this user. The actual user name is not relevant so please use a hash. It needs to be unique for user. Here's an example of how you can send a message to all devices for user. The only difference is that instead of sending a message to our insertion ID we now send it to a notification key. Now let's assume a user on one device acts on the notification and we want to dismiss this from all other devices. How do we do it with upstream messaging. We can send a message to a notification key and GCM will deliver the message to all other registrations in this key this way. You can tell other devices to dismiss the notification as it is already handle on one device. In addition you can also send this message to your application server by sending it to a project Patey in a separate upstream message. Here's an example as you can see that to fill in the upstream message is set to a notification key. This will make GCM send this message to all other devices that are part of this key. Using notifications is available on both SATB annex and Peepy. It allows a max of Thracians per notification key. And of course the key name in the request should be unique to the user. Before we end I like you please check out our updated documentation for all GCM API as services. As always it's available at this link here.
SPEAKER: M2
Thank you for watching and I hope you are excited to use this new API and services and enjoy this video